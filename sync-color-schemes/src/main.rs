use crate::scheme::Scheme;
use anyhow::Context;
use config::ColorSchemeFile;
use sqlite_cache::Cache;
use std::collections::BTreeMap;
use std::path::Path;
use std::time::Duration;
use wezterm_dynamic::{ToDynamic, Value};

mod base16;
mod gogh;
mod iterm2;
mod scheme;
mod sexy;

lazy_static::lazy_static! {
    static ref CACHE: Cache = make_cache();
}

fn make_cache() -> Cache {
    let file_name = "/tmp/wezterm-sync-color-schemes.sqlite";
    let connection = sqlite_cache::rusqlite::Connection::open(&file_name).unwrap();
    Cache::new(sqlite_cache::CacheConfig::default(), connection).unwrap()
}

pub async fn fetch_url_as_str(url: &str) -> anyhow::Result<String> {
    let data = fetch_url(url)
        .await
        .with_context(|| format!("fetching {url}"))?;
    String::from_utf8(data).with_context(|| format!("converting data from {url} to string"))
}

pub async fn fetch_url(url: &str) -> anyhow::Result<Vec<u8>> {
    let topic = CACHE.topic("data-by-url").context("creating cache topic")?;

    let (updater, item) = topic
        .get_for_update(url)
        .await
        .context("lookup url in cache")?;
    if let Some(item) = item {
        return Ok(item.data);
    }

    println!("Going to request {url}");
    let client = reqwest::Client::builder()
        .user_agent("wezterm-sync-color-schemes/1.0")
        .build()?;

    let response = client
        .get(url)
        .send()
        .await
        .with_context(|| format!("fetching {url}"))?;
    let mut ttl = Duration::from_secs(86400);
    if let Some(value) = response.headers().get(reqwest::header::CACHE_CONTROL) {
        if let Ok(value) = value.to_str() {
            let fields = value.splitn(2, "=").collect::<Vec<_>>();
            if fields.len() == 2 && fields[0] == "max-age" {
                if let Ok(secs) = fields[1].parse::<u64>() {
                    ttl = Duration::from_secs(secs);
                }
            }
        }
    }

    let status = response.status();

    let data = response.bytes().await?.to_vec();

    if status != reqwest::StatusCode::OK {
        anyhow::bail!("{}", String::from_utf8_lossy(&data));
    }

    updater.write(&data, ttl).context("assigning to cache")?;
    Ok(data)
}

fn make_prefix(s: &str) -> (char, String) {
    let fields: Vec<_> = s.splitn(2, ':').collect();
    let key = fields.last().unwrap();
    for c in key.chars() {
        match c {
            '0'..='9' | 'a'..='z' => return (c, key.to_ascii_lowercase()),
            'A'..='Z' => return (c.to_ascii_lowercase(), key.to_ascii_lowercase()),
            _ => continue,
        }
    }
    panic!("no good prefix");
}

fn safe_file_name(s: &str) -> String {
    s.chars()
        .map(|c| match c {
            c @ 'a'..='z' => c,
            c @ 'A'..='Z' => c,
            c @ '0'..='9' => c,
            c @ '('..=')' => c,
            ' ' => ' ',
            _ => '-',
        })
        .collect()
}

fn bake_for_config(schemeses: Vec<Scheme>) -> anyhow::Result<()> {
    let mut all = vec![];

    let count = schemeses.len();
    let mut code = String::new();
    code.push_str(&format!(
        "//! This file was generated by sync-color-schemes\n
pub const SCHEMES: [(&'static str, &'static str); {count}] = [\n
    // Start here
",
    ));
    for s in &schemeses {
        let name = s.name.escape_default();
        let toml = s.to_toml()?;
        let toml = toml.escape_default();
        code.push_str(&format!("(\"{name}\", \"{toml}\"),\n",));

        all.push(s);
    }
    code.push_str("];\n");

    let file_name = "config/src/scheme_data.rs";
    let update = match std::fs::read_to_string(file_name) {
        Ok(existing) => existing != code,
        Err(_) => true,
    };

    if update {
        eprintln!("Updating {file_name}");
        std::fs::write(file_name, code)?;
    }

    // And the data for the docs

    all.sort_by_key(|s| make_prefix(&s.name));
    let mut doc_data = vec![];
    for s in all {
        doc_data.push(s.to_json_value()?);
    }

    let file_name = "docs/colorschemes/data.json";
    let json = serde_json::to_string_pretty(&doc_data)?;
    let update = match std::fs::read_to_string(file_name) {
        Ok(existing) => existing != json,
        Err(_) => true,
    };

    if update {
        eprintln!("Updating {file_name}");
        std::fs::write(file_name, json)?;
    }

    Ok(())
}

fn accumulate(schemeses: &mut Vec<Scheme>, to_add: Vec<Scheme>) {
    // Only accumulate if the scheme looks different enough
    'skip_candidate: for candidate in to_add {
        for existing in schemeses.iter() {
            if candidate.data.colors.ansi == existing.data.colors.ansi
                && candidate.data.colors.brights == existing.data.colors.brights
                && candidate.data.colors.foreground == existing.data.colors.foreground
                && candidate.data.colors.background == existing.data.colors.background
            {
                println!("{} is same as {}", candidate.name, existing.name);
                continue 'skip_candidate;
            }
        }

        schemeses.push(candidate);
    }
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // They color us! my precious!
    let mut schemeses = iterm2::sync_iterm2().context("sync iterm2")?;
    accumulate(&mut schemeses, base16::sync().await.context("sync base16")?);
    accumulate(
        &mut schemeses,
        gogh::sync_gogh().await.context("sync gogh")?,
    );
    accumulate(&mut schemeses, sexy::sync_sexy().context("sync sexy")?);
    bake_for_config(schemeses)?;

    Ok(())
}
