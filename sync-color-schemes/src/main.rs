use crate::scheme::Scheme;
use anyhow::Context;
use config::{ColorSchemeFile, ColorSchemeMetaData, Palette, RgbaColor};
use http_req::request::{HttpVersion, Request};
use http_req::uri::Uri;
use serde::Deserialize;
use std::collections::BTreeMap;
use std::path::Path;
use std::time::Duration;
use wezterm_dynamic::{ToDynamic, Value};

mod gogh;
mod iterm2;
mod scheme;
mod sexy;

fn make_prefix(s: &str) -> (char, String) {
    let fields: Vec<_> = s.splitn(2, ':').collect();
    let key = fields.last().unwrap();
    for c in key.chars() {
        match c {
            '0'..='9' | 'a'..='z' => return (c, key.to_ascii_lowercase()),
            'A'..='Z' => return (c.to_ascii_lowercase(), key.to_ascii_lowercase()),
            _ => continue,
        }
    }
    panic!("no good prefix");
}

fn safe_file_name(s: &str) -> String {
    s.chars()
        .map(|c| match c {
            c @ 'a'..='z' => c,
            c @ 'A'..='Z' => c,
            c @ '0'..='9' => c,
            c @ '('..=')' => c,
            ' ' => ' ',
            _ => '-',
        })
        .collect()
}

fn bake_for_config(schemeses: Vec<Scheme>) -> anyhow::Result<()> {
    let mut all = vec![];

    let count = schemeses.len();
    let mut code = String::new();
    code.push_str(&format!(
        "//! This file was generated by sync-color-schemes\n
pub const SCHEMES: [(&'static str, &'static str); {count}] = [\n
    // Start here
",
    ));
    for s in &schemeses {
        let name = s.name.escape_default();
        let toml = s.to_toml()?;
        let toml = toml.escape_default();
        code.push_str(&format!("(\"{name}\", \"{toml}\"),\n",));

        all.push(s);
    }
    code.push_str("];\n");

    let file_name = "config/src/scheme_data.rs";
    let update = match std::fs::read_to_string(file_name) {
        Ok(existing) => existing != code,
        Err(_) => true,
    };

    if update {
        eprintln!("Updating {file_name}");
        std::fs::write(file_name, code)?;
    }

    // And the data for the docs

    all.sort_by_key(|s| make_prefix(&s.name));
    let mut doc_data = vec![];
    for s in all {
        doc_data.push(s.to_json_value()?);
    }

    let file_name = "docs/colorschemes/data.json";
    let json = serde_json::to_string_pretty(&doc_data)?;
    let update = match std::fs::read_to_string(file_name) {
        Ok(existing) => existing != json,
        Err(_) => true,
    };

    if update {
        eprintln!("Updating {file_name}");
        std::fs::write(file_name, json)?;
    }

    Ok(())
}

fn accumulate(schemeses: &mut Vec<Scheme>, to_add: Vec<Scheme>) {
    // Only accumulate if the scheme looks different enough
    'skip_candidate: for candidate in to_add {
        for existing in schemeses.iter() {
            if candidate.data.colors.ansi == existing.data.colors.ansi
                && candidate.data.colors.brights == existing.data.colors.brights
                && candidate.data.colors.foreground == existing.data.colors.foreground
                && candidate.data.colors.background == existing.data.colors.background
            {
                println!("{} is same as {}", candidate.name, existing.name);
                continue 'skip_candidate;
            }
        }

        schemeses.push(candidate);
    }
}

fn main() -> anyhow::Result<()> {
    // They color us! my precious!
    let mut schemeses = iterm2::sync_iterm2()?;
    accumulate(&mut schemeses, gogh::sync_gogh()?);
    accumulate(&mut schemeses, sexy::sync_sexy()?);
    bake_for_config(schemeses)?;

    Ok(())
}
